# -*- coding: utf-8 -*-
"""Diabetic_project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1q5iWl7ommzjyTfFqN-00WkKUzqE9JQay

Computer Vision
Problem Statement: Automated Diagnosis of Diabetic Retinopathy
Background.

Diabetic Retinopathy (DR) is a serious complication of diabetes that damages the retina, potentially leading to vision loss. With the rising prevalence of diabetes, DR has become a significant public health concern. Early detection and timely intervention are vital for preventing severe vision impairment and improving patient outcomes. However, the current methods of diagnosing DR through manual interpretation of retinal images are labor-intensive and prone to human error, making them inefficient and inconsistent.

Objective
The goal is to develop an automated and accurate tool for diagnosing Diabetic Retinopathy using retinal images. This tool should assist healthcare professionals by providing consistent and reliable grading of DR severity, thus facilitating early intervention and personalized treatment plans.

Dataset Description
The dataset comprises a large collection of high-resolution retinal images captured under various imaging conditions. Each image has been assessed by a medical professional, who determined the presence of Diabetic Retinopathy and assigned a binary rating:

0: Diabetic Retinopathy
1: No Diabetic Retinopathy

Challenges

Subjectivity and Manual Labor: Current methods rely on subjective assessments, which can lead to inconsistencies and inefficiencies.

Increasing Prevalence: The rising number of diabetes cases and the limited availability of ophthalmologists exacerbate the need for timely and accurate screening.

Imaging Variability: The dataset includes images captured under different conditions, which may affect the consistency of the automated diagnosis.

Solution

To address these challenges, an automated system utilizing advanced machine learning techniques will be developed. This system aims to:

Accurately detect and grade Diabetic Retinopathy from retinal images.
Provide consistent and reliable results, reducing the dependence on subjective human interpretation.

Enable early detection and intervention, improving patient outcomes.

Impact

Implementing an automated DR diagnosis system will streamline the screening process, reduce the workload on healthcare professionals, and ensure timely and accurate diagnosis. This will ultimately lead to better management of Diabetic Retinopathy and improved vision health for patients with diabetes.
"""

!pip install tensorflow --q

import os
import matplotlib.pyplot as plt
import numpy as np
import tensorflow as tf
from tensorflow.keras import layers
from tensorflow.keras.models import Sequential
from sklearn.model_selection import train_test_split
from pathlib import Path
import random
from keras.layers import Conv2D, MaxPooling2D, Flatten,Dense,Dropout

# Set seeds for reproducibility
tf.random.set_seed(42)
np.random.seed(42)
random.seed(42)

from google.colab import drive
drive.mount('/content/drive')

# Path to your folder in Google Drive
folder_path = '/content/drive/My Drive/Project 3/Diabetic/RETINOPATHY/Diabetic_Retinopathy/train'

# Verify the directory exists
if os.path.exists(folder_path):
    # List files in the folder
    total_classes = os.listdir(folder_path)
    print(total_classes)
else:
    print(f"The directory {folder_path} does not exist.")

# Load images and labels
def load_data(folder_path):
    images = []
    labels = []
    for label, category in enumerate(total_classes):
        category_path = Path(folder_path) / category
        for image_path in category_path.glob('*.jpg'):
            img = tf.keras.preprocessing.image.load_img(image_path, target_size=(224, 224))
            img_array = tf.keras.preprocessing.image.img_to_array(img)
            images.append(img_array)
            labels.append(label)
    return np.array(images), np.array(labels)

X, y = load_data(folder_path)
print(f'Total images: {len(X)}, Total labels: {len(y)}')

#Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Normalize the data
X_train = X_train / 255.0
X_test = X_test / 255.0

# Identify the class label for DR
DR_label = 1

# Filter images belonging to the DR class
DR_indices = np.where(y_train == DR_label)[0]

plt.figure(figsize=(10, 10))
for i in range(3):
  ax = plt.subplot(1, 3, i + 1)
  plt.imshow(X_train[DR_indices[i]])
  plt.title("DR")
  plt.axis("off")

# Identify the class label for NO_DR
NO_DR_label = 0

# Filter images belonging to the NO_DR class
NO_DR_indices = np.where(y_train == NO_DR_label)[0]


plt.figure(figsize=(10, 10))
for i in range(3):
  ax = plt.subplot(1, 3, i + 1)
  plt.imshow(X_train[NO_DR_indices[i]])
  plt.title("NO_DR")
  plt.axis("off")
plt.show()

#Neutral Network Architecture
model= Sequential([
    Conv2D(128, kernel_size = (3,3), input_shape= (224,224,3),activation = 'relu'),
    MaxPooling2D(pool_size = (2,2)),
    Conv2D(64, kernel_size = (3,3),activation = 'relu'),
    MaxPooling2D(pool_size = (2,2)),
    Conv2D(64, kernel_size = (3,3),activation = 'relu'),
    MaxPooling2D(pool_size = (2,2)),
    Flatten(),
    Dense(len(y),activation= 'sigmoid'),
])

#Compile model
model.compile(optimizer='adam',
              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=['accuracy'])

# Train the model
history = model.fit(X_train,y_train, epochs=15,batch_size=16,
                    validation_data=(X_test, y_test), verbose=1)

from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, classification_report, confusion_matrix

# Make predictions
y_pred = model.predict(X_test)

#evaluate the model
test_loss,test_acc = model.evaluate(X_test, y_test, verbose =1)
print(f'Test accuracy:{test_acc}')

#evaluate the model
train_loss,train_acc = model.evaluate(X_train, y_train, verbose =1)
print(f'Train accuracy:{test_acc}')

#visualize training history
plt.figure(figsize=(14, 5))
plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Training Accuracy')
plt.plot(history.history['val_accuracy'], label='Validation Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.title('Training and Validation Accuracy')
plt.legend

plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Training Loss')
plt.plot(history.history['val_loss'], label='Validation Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.title('Training and Validation Loss')
plt.legend

"""The model aims to predict the outcomes of patients' tests for diabetic retinopathy. It currently achieves an accuracy of 96.51%, indicating that it has learned the patterns in the data reasonably well. However, there is potential for further improvement to enhance its predictive performance.

"""